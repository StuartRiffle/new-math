# Counter automaton prototype

def odd_core(n):
    k = 0
    while n and n & 1 == 0:
        n >>= 1
        k += 1
    return n, k

def get_automaton(n):
    ocl, kl = odd_core(n - 1)
    ocr, kr = odd_core(n + 1)
    return (ocl, kl, ocr, kr)

def step_automaton(t):
    if t == (0, 0, 1, 1):
        return t
    
    ocl, kl, ocr, kr = t

    if kl >= 3 and kr == 1: # n ≡ 1 (mod 8)
        ocl, kl = 3 * ocl, kl - 2
        ocr, kr = ocl * (1 << (kl - 1)) + 1, 1

    elif kr >= 2 and kl == 1: # n ≡ 3 (mod 4)
        ocr, kr = 3 * ocr, kr - 1
        ocl, kl = ocr * (1 << (kr - 1)) - 1, 1

    else: # n ≡ 5 (mod 8) 
        assert(kl == 2 and kr == 1)

        # We can predict the next k drop without using the +1 carry to roll over factors,
        # by counting low *set* bits of ocl*3 (because they are the ones about to flip)

        k = 1
        m = ocl * 3
        while m & 1 == 1:
            m >>= 1
            k  += 1
        
        next = (ocl * 3 + 1) >> k
        kl, kr = (2, 1) if next % 4 == 1 else (1, 2)
        ocl, ocr = (next - 1) >> kl, (next + 1) >> kr

    return (ocl, kl, ocr, kr)


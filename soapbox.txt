[clears throat and inhales deeply]

<soapbox>
- The Collatz map can be defined as a shift left in ternary, and a shift right in binary, with a +1 operation in between.
- Both shifts are information preserving, because they only shuffle zeroes. Pushing n around in this base or the other is reversible, so no information is lost.
- A full iteration exchanges k for new congruence information, which is propagated forward thereafter by the CRT.
- The binary avalanche caused by +1 is the only meaningful change of state in the Collatz map. The shifts are temporary and informationally harmless.
- The number of bits flipped in the avalanche is k.
- The per-step information evolution of Collatz is proportional to k. The nature of it is isomorphic to the rules of carry propagation.
- (As an aside, this is why Minsky's two-tag machine traces Collatz: it's a cleverly obfuscated carry-propagator).
- The binary carry avalanche maximizes diffusion in the dyadic hierarchy.
- Each bit flipped shuffles the corresponding mod 2^k class, erasing low-order memory.
- The LSB of n under the odd-to-odd map is always 1 (because it's odd). The must also be an MSB _somewhere_ (because we're still playing Collatz, so n > 1).
- These can be considered delimiters without informational value. The interior "payload" bits completely determine the state of the process, which ends when the delimiters join (at 1).
- The MSB is a placeholder that protects the leading zeroes in the payload. The LSB protects the trailing zeroes, and serves as a "stop" during the /2 normalization step. Together they form a frame.
- The interior bits as a string form a symbolic progression, isomorphic to the arithmetic by construction (you can wrap the string in delimiters again to recover n, so a 1:1 mapping).
- It's really unfortunate that the (meaningless) MSB of n has the largest effect on magnitude, that sure doesn't help things.
- Define the "natural" order of prime factor sets to be the one arising as you simply increment integers: {}, {2}, {3}, {2}, {5}, {2,3}, and so on.
- Natural ordering is a constrained mapping: successive integers share no factors.
- The +1 operation is a permutation on all prime integer rings at once.
- It is a full mixing of the residue vectors modulo any finite set of odd primes.
- The sequence is also cyclical modulo the product of primes.
- 3n is an affine transform with full coverage over prime rings: a permutation.
- Collatz is therefore a permutation of the natural order of factor sets.
- That's a wreath product.
- 3n can only add a factor of 3, the rest of the factor set is unchanged.
- The same is true of /2: scaling by powers of two can't add or remove odd prime factors.
- The set of prime factors above 3 is therefore chaos-invariant, and we can reason about its long term evolution.
- The +1 operation breaks multiplicative alignment with the product of the prime factors of n.
- Forever, because the CRT never forgets.
- Which means n doesn't cycle.
- The process of accumulating coprimality through iteration acts like a sieve over odd prime product lattices.
- In aggregate these observations establish an information channel that amounts to an "odd prime factor set cursor", and it cycles.
- The coprimality is propagated forward by the CRT, forcing n to (effectively) enumerate odd prime factor sets.
- The sets of odd prime factors above three for odd numbers on a Collatz orbit are therefore disjoint. Each unique combination of those factors will be seen only once. This is the cursor walk.
- This is independent of factor exponent. Gaining coprimality with 5x7 (for example) also makes n coprime to 5^2x7^3.
- Many small values of n share factor sets that differ only in their exponents. These are a "jackpot" of coprimality, because the entire equivalence class of composite numbers is sieved out together.
- Non-factor residues appear scrambled because they are mutating to maintain existing odd congruences in a constrained way. This is a feature, not a bug.
- Eventual misalignment with all odd prime factor sets under the Collatz map will force n to a power of two.
- Because what's evolving is "the set of odd prime factors above three", the actual magnitude of n at any time has little value. It is a pointer to the richer state information in n's local neighborhood.
- The value of n never repeats. This is a clue, because doing that long term requires non-trivial persistent state.
- Long orbits can pass through small values of n and recover, which is another clue: that requires indirection. A handful of bits can't hold enough state to support the complex long term behavior observed; n must represent something more than itself.
- Collatz runs in the space of prime residues, which represent CRT constraint state. This determines congruence (or lack thereof). The value of n is indexing this space. It is chaotic-looking but stepping very carefully.
- Accumulating modular constraint is the reason n seems to find so many prime numbers: it has no choice. As n becomes coprime with common factor sets, composite numbers become unreachable.
- The arithmetic properties of n are completely determined by the 2-adic valuations (odd core and k exponent) of its two immediate even neighbors n-1 and n+1.
- This pair of 2-adic valuations (4-tuple of integers) uniquely identifies n, like a fingerprint.
- The Collatz process can run directly on these fingerprints. You don't have to look at n.
- It is therefore a finite state transducer.
- Linking odd numbers to the 2-adic odd cores of their even neighbors forms a fractal DAG over odd integers.
- I am as surprised as you are.
- The Collatz map contains infinite sequences of deterministic "almost-doublings" that form an odd-to-odd stopping time equivalence class.
- Using the graph and always following the link with lowest k-value reduces astronomical n to representative "seed" values for the equivalence class in log2 n steps.
- The seed values represent the first appearance of a specific unique odd prime factor set in the integers.
- There is an infinitude of such seeds, because there is an infinitude of prime numbers, and therefore factor sets.
- The seeds are are canonical for the entire infinite class of composite numbers sharing their factor set. The Collatz problem reduces to solving stopping time for these factor set seeds.
- Each odd seed is the base of an infinite 2-adic chain of even multiples of powers of two.
- These even numbers are an odd-to-odd stopping time equivalence class, because the Collatz /2 rule collapses them all immediately to the same odd seed.
- Seeds partition the set of odd integers into classes: every odd number belongs to exactly one seed’s “doubling chain”.
- Adjacent to every even number on the seed's doubling chain are two odd neighbors. One or both will have the same odd-to-odd stopping time as the seed.
- Some odd composite numbers work as "hubs" where multiple seed chains join, and the rest of the path is shared.
- The hubs are fed by connectors with a similar (but simpler) pattern of doubling, these feed into it.
- The pattern of self-similar odd core connectivity is unavoidable, because even at astronomical scale, the rules of 2-adic valuation (remove all power of two factors) connect n to much smaller odd core values. The odd cores have unlimited "reach" in this way.
- In portions of the graph there are levels of connectivity corresponding to exactly 6 steps of orbit.
- Continuing from a seed, using the lowest-k traversal rule, collapses all seeds to 1, again with log2 n complexity.
- The odd-to-odd stopping distance of a seed can be calculated by summing the k values of the branches *not* taken along the path from seed to root, and adding a baseline cost of 4.
- There are three exceptions to this formula, related to quirks in the rules of Collatz that allow "shortcuts" past the general traversal rules.
- The first is a class of trivial seeds of the form n = (2^m - 1) / 3, meaning that they will reach a power of two on the next step, for example 5, 21, 85, etc. They do not finish traversing the tree, and have a fixed odd-to-odd stopping distance of 1, requiring a correction factor of -3.
- The second special case is similar and applies when the lowest-k path bypasses a connection to one of fundamental seeds 1 or 3. This pattern also requires a correction of -3.
- The final special case 

- Intermediate values of n are no longer an equivalence class, and the trunk collapses into a shared path very quickly, usually withing a couple of steps. 
- This complete walk (n -> seed -> 1) uniquely identifies n.
</soapbox>

[collapses gasping]

---
These notes represent work in progress and of course prove nothing; standard disclaimers apply.
